<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Zero Inflated Models in Bambi | Gabe&#39;s Gulch</title>
<meta name="keywords" content="">
<meta name="description" content="
#| code-fold: true
import arviz as az
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import numpy as np
import pandas as pd
import scipy.stats as stats
import seaborn as sns
import warnings

import bambi as bmb

warnings.simplefilter(action=&#39;ignore&#39;, category=FutureWarning)
WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions.

Zero inflated models
This blog post is a copy of the zero inflated models documentation I wrote for Bambi. The original post can be found here.">
<meta name="author" content="Gabriel Stechschulte">
<link rel="canonical" href="https://gstechschulte.github.io/posts/bambi-zip-models/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://gstechschulte.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://gstechschulte.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://gstechschulte.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://gstechschulte.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://gstechschulte.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://gstechschulte.github.io/posts/bambi-zip-models/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"
    integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV"
    crossorigin="anonymous"
/>
<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"
    integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8"
    crossorigin="anonymous"
></script>
<script
    defer
    src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
    integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05"
    crossorigin="anonymous"
></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true },
            ],
            throwOnError: false,
        });
    });
</script>

<meta property="og:title" content="Zero Inflated Models in Bambi" />
<meta property="og:description" content="
#| code-fold: true
import arviz as az
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import numpy as np
import pandas as pd
import scipy.stats as stats
import seaborn as sns
import warnings

import bambi as bmb

warnings.simplefilter(action=&#39;ignore&#39;, category=FutureWarning)
WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions.

Zero inflated models
This blog post is a copy of the zero inflated models documentation I wrote for Bambi. The original post can be found here." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://gstechschulte.github.io/posts/bambi-zip-models/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-29T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-09-29T00:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Zero Inflated Models in Bambi"/>
<meta name="twitter:description" content="
#| code-fold: true
import arviz as az
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import numpy as np
import pandas as pd
import scipy.stats as stats
import seaborn as sns
import warnings

import bambi as bmb

warnings.simplefilter(action=&#39;ignore&#39;, category=FutureWarning)
WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions.

Zero inflated models
This blog post is a copy of the zero inflated models documentation I wrote for Bambi. The original post can be found here."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://gstechschulte.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Zero Inflated Models in Bambi",
      "item": "https://gstechschulte.github.io/posts/bambi-zip-models/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Zero Inflated Models in Bambi",
  "name": "Zero Inflated Models in Bambi",
  "description": " #| code-fold: true import arviz as az import matplotlib.pyplot as plt from matplotlib.lines import Line2D import numpy as np import pandas as pd import scipy.stats as stats import seaborn as sns import warnings import bambi as bmb warnings.simplefilter(action=\u0026#39;ignore\u0026#39;, category=FutureWarning) WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions. Zero inflated models This blog post is a copy of the zero inflated models documentation I wrote for Bambi. The original post can be found here.\n",
  "keywords": [
    
  ],
  "articleBody": " #| code-fold: true import arviz as az import matplotlib.pyplot as plt from matplotlib.lines import Line2D import numpy as np import pandas as pd import scipy.stats as stats import seaborn as sns import warnings import bambi as bmb warnings.simplefilter(action='ignore', category=FutureWarning) WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions. Zero inflated models This blog post is a copy of the zero inflated models documentation I wrote for Bambi. The original post can be found here.\nIn this notebook, we will describe zero inflated outcomes and why the data generating process behind these outcomes requires a special class of generalized linear models: zero-inflated Poisson (ZIP) and hurdle Poisson. Subsequently, we will describe and implement each model using a set of zero-inflated data from ecology. Along the way, we will also use the interpret sub-package to interpret the predictions and parameters of the models.\nZero inflated outcomes Sometimes, an observation is not generated from a single process, but from a mixture of processes. Whenever there is a mixture of processes generating an observation, a mixture model may be more appropriate. A mixture model uses more than one probability distribution to model the data. Count data are more susceptible to needing a mixture model as it is common to have a large number of zeros and values greater than zero. A zero means “nothing happened”, and this can be either because the rate of events is low, or because the process that generates the events was never “triggered”. For example, in health service utilization data (the number of times a patient used a service during a given time period), a large number of zeros represents patients with no utilization during the time period. However, some patients do use a service which is a result of some “triggered process”.\nThere are two popular classes of models for modeling zero-inflated data: (1) ZIP, and (2) hurdle Poisson. First, the ZIP model is described and how to implement it in Bambi is outlined. Subsequently, the hurdle Poisson model and how to implement it is outlined thereafter.\nZero inflated poisson To model zero-inflated outcomes, the ZIP model uses a distribution that mixes two data generating processes. The first process generates zeros, and the second process uses a Poisson distribution to generate counts (of which some may be zero). The result of this mixture is a distribution that can be described as\n$$P(Y=0) = (1 - \\psi) + \\psi e^{-\\mu}$$\n$$P(Y=y_i) = \\psi \\frac{e^{-\\mu} \\mu_{i}^y}{y_{i}!} \\ \\text{for} \\ y_i = 1, 2, 3,…,n$$\nwhere $y_i$ is the outcome, $\\mu$ is the mean of the Poisson process where $\\mu \\ge 0$, and $\\psi$ is the probability of the Poisson process where $0 \\lt \\psi \\lt 1$. To understand how these two processes are “mixed”, let’s simulate some data using the two process equations above (taken from the PyMC docs).\nx = np.arange(0, 22) psis = [0.7, 0.4] mus = [10, 4] plt.figure(figsize=(7, 3)) for psi, mu in zip(psis, mus): pmf = stats.poisson.pmf(x, mu) pmf[0] = (1 - psi) + pmf[0] # 1.) generate zeros pmf[1:] = psi * pmf[1:] # 2.) generate counts pmf /= pmf.sum() # normalize to get probabilities plt.plot(x, pmf, '-o', label='$\\\\psi$ = {}, $\\\\mu$ = {}'.format(psi, mu)) plt.title(\"Zero Inflated Poisson Process\") plt.xlabel('x', fontsize=12) plt.ylabel('f(x)', fontsize=12) plt.legend(loc=1) plt.show() Notice how the blue line, corresponding to a higher $\\psi$ and $\\mu$, has a higher rate of counts and less zeros. Additionally, the inline comments above describe the first and second process generating the data.\nZIP regression model The equations above only describe the ZIP distribution. However, predictors can be added to make this a regression model. Suppose we have a response variable $Y$, which represents the number of events that occur during a time period, and $p$ predictors $X_1, X_2, …, X_p$. We can model the parameters of the ZIP distribution as a linear combination of the predictors.\n$$Y_i \\sim \\text{ZIPoisson}(\\mu_i, \\psi_i)$$\n$$g(\\mu_i) = \\beta_0 + \\beta_1 X_{1i}+,…,+\\beta_p X_{pi}$$\n$$h(\\psi_i) = \\alpha_0 + \\alpha_1 X_{1i}+,…,+\\alpha_p X_{pi}$$\nwhere $g$ and $h$ are the link functions for each parameter. Bambi, by default, uses the log link for $g$ and the logit link for $h$. Notice how there are two linear models and two link functions: one for each parameter in the $\\text{ZIPoisson}$. The parameters of the linear model differ, because any predictor such as $X$ may be associated differently with each part of the mixture. Actually, you don’t even need to use the same predictors in both linear models—but this beyond the scope of this notebook.\nThe fish dataset To demonstrate the ZIP regression model, we model and predict how many fish are caught by visitors at a state park using survey data. Many visitors catch zero fish, either because they did not fish at all, or because they were unlucky. The dataset contains data on 250 groups that went to a state park to fish. Each group was questioned about how many fish they caught (count), how many children were in the group (child), how many people were in the group (persons), if they used a live bait (livebait) and whether or not they brought a camper to the park (camper).\nfish_data = pd.read_stata(\"http://www.stata-press.com/data/r11/fish.dta\") cols = [\"count\", \"livebait\", \"camper\", \"persons\", \"child\"] fish_data = fish_data[cols] fish_data[\"livebait\"] = pd.Categorical(fish_data[\"livebait\"]) fish_data[\"camper\"] = pd.Categorical(fish_data[\"camper\"]) fish_data = fish_data[fish_data[\"count\"] \u003c 60] # remove outliers fish_data.head() .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } # Excess zeros, and skewed count plt.figure(figsize=(7, 3)) sns.histplot(fish_data[\"count\"], discrete=True) plt.xlabel(\"Number of Fish Caught\"); To fit a ZIP regression model, we pass family=zero_inflated_poisson to the bmb.Model constructor.\nzip_model = bmb.Model( \"count ~ livebait + camper + persons + child\", fish_data, family='zero_inflated_poisson' ) zip_idata = zip_model.fit( draws=1000, target_accept=0.95, random_seed=1234, chains=4 ) Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs) NUTS: [count_psi, Intercept, livebait, camper, persons, child] Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 4 seconds. Lets take a look at the model components. Why is there only one linear model and link function defined for $\\mu$. Where is the linear model and link function for $\\psi$? By default, the “main” (or first) formula is defined for the parent parameter; in this case $\\mu$. Since we didn’t pass an additional formula for the non-parent parameter $\\psi$, $\\psi$ was never modeled as a function of the predictors as explained above. If we want to model both $\\mu$ and $\\psi$ as a function of the predictor, we need to expicitly pass two formulas.\nzip_model Formula: count ~ livebait + camper + persons + child Family: zero_inflated_poisson Link: mu = log Observations: 248 Priors: target = mu Common-level effects Intercept ~ Normal(mu: 0.0, sigma: 9.5283) livebait ~ Normal(mu: 0.0, sigma: 7.2685) camper ~ Normal(mu: 0.0, sigma: 5.0733) persons ~ Normal(mu: 0.0, sigma: 2.2583) child ~ Normal(mu: 0.0, sigma: 2.9419) Auxiliary parameters psi ~ Beta(alpha: 2.0, beta: 2.0) ------ * To see a plot of the priors call the .plot_priors() method. * To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace() formula = bmb.Formula( \"count ~ livebait + camper + persons + child\", # parent parameter mu \"psi ~ livebait + camper + persons + child\" # non-parent parameter psi ) zip_model = bmb.Model( formula, fish_data, family='zero_inflated_poisson' ) zip_idata = zip_model.fit( draws=1000, target_accept=0.95, random_seed=1234, chains=4 ) Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs) NUTS: [Intercept, livebait, camper, persons, child, psi_Intercept, psi_livebait, psi_camper, psi_persons, psi_child] Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 6 seconds. zip_model Formula: count ~ livebait + camper + persons + child psi ~ livebait + camper + persons + child Family: zero_inflated_poisson Link: mu = log psi = logit Observations: 248 Priors: target = mu Common-level effects Intercept ~ Normal(mu: 0.0, sigma: 9.5283) livebait ~ Normal(mu: 0.0, sigma: 7.2685) camper ~ Normal(mu: 0.0, sigma: 5.0733) persons ~ Normal(mu: 0.0, sigma: 2.2583) child ~ Normal(mu: 0.0, sigma: 2.9419) target = psi Common-level effects psi_Intercept ~ Normal(mu: 0.0, sigma: 1.0) psi_livebait ~ Normal(mu: 0.0, sigma: 1.0) psi_camper ~ Normal(mu: 0.0, sigma: 1.0) psi_persons ~ Normal(mu: 0.0, sigma: 1.0) psi_child ~ Normal(mu: 0.0, sigma: 1.0) ------ * To see a plot of the priors call the .plot_priors() method. * To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace() Now, both $\\mu$ and $\\psi$ are defined as a function of a linear combination of the predictors. Additionally, we can see that the log and logit link functions are defined for $\\mu$ and $\\psi$, respectively.\nzip_model.graph() Since each parameter has a different link function, and each parameter has a different meaning, we must be careful on how the coefficients are interpreted. Coefficients without the substring “psi” correspond to the $\\mu$ parameter (the mean of the Poisson process) and are on the log scale. Coefficients with the substring “psi” correspond to the $\\psi$ parameter (this can be thought of as the log-odds of non-zero data) and are on the logit scale. Interpreting these coefficients can be easier with the interpret sub-package. Below, we will show how to use this sub-package to interpret the coefficients conditional on a set of the predictors.\naz.summary( zip_idata, var_names=[\"Intercept\", \"livebait\", \"camper\", \"persons\", \"child\"], filter_vars=\"like\" ) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Interpret model parameters Since we have fit a distributional model, we can leverage the plot_predictions() function in the interpret sub-package to visualize how the $\\text{ZIPoisson}$ parameters $\\mu$ and $\\psi$ vary as a covariate changes.\nfig, ax = plt.subplots(nrows=1, ncols=2, figsize=(10, 3)) bmb.interpret.plot_predictions( zip_model, zip_idata, covariates=\"persons\", ax=ax[0] ) ax[0].set_ylabel(\"mu (fish count)\") ax[0].set_title(\"$\\\\mu$ as a function of persons\") bmb.interpret.plot_predictions( zip_model, zip_idata, covariates=\"persons\", target=\"psi\", ax=ax[1] ) ax[1].set_title(\"$\\\\psi$ as a function of persons\"); Interpreting the left plot (the $\\mu$ parameter) as the number of people in a group fishing increases, so does the number of fish caught. The right plot (the $\\psi$ parameter) shows that as the number of people in a group fishing increases, the probability of the Poisson process increases. One interpretation of this is that as the number of people in a group increases, the probability of catching no fish decreases.\nPosterior predictive distribution Lastly, lets plot the posterior predictive distribution against the observed data to see how well the model fits the data. To plot the samples, a utility function is defined below to assist in the plotting of discrete values.\ndef adjust_lightness(color, amount=0.5): import matplotlib.colors as mc import colorsys try: c = mc.cnames[color] except: c = color c = colorsys.rgb_to_hls(*mc.to_rgb(c)) return colorsys.hls_to_rgb(c[0], c[1] * amount, c[2]) def plot_ppc_discrete(idata, bins, ax): def add_discrete_bands(x, lower, upper, ax, **kwargs): for i, (l, u) in enumerate(zip(lower, upper)): s = slice(i, i + 2) ax.fill_between(x[s], [l, l], [u, u], **kwargs) var_name = list(idata.observed_data.data_vars)[0] y_obs = idata.observed_data[var_name].to_numpy() counts_list = [] for draw_values in az.extract(idata, \"posterior_predictive\")[var_name].to_numpy().T: counts, _ = np.histogram(draw_values, bins=bins) counts_list.append(counts) counts_arr = np.stack(counts_list) qts_90 = np.quantile(counts_arr, (0.05, 0.95), axis=0) qts_70 = np.quantile(counts_arr, (0.15, 0.85), axis=0) qts_50 = np.quantile(counts_arr, (0.25, 0.75), axis=0) qts_30 = np.quantile(counts_arr, (0.35, 0.65), axis=0) median = np.quantile(counts_arr, 0.5, axis=0) colors = [adjust_lightness(\"C0\", x) for x in [1.8, 1.6, 1.4, 1.2, 0.9]] add_discrete_bands(bins, qts_90[0], qts_90[1], ax=ax, color=colors[0]) add_discrete_bands(bins, qts_70[0], qts_70[1], ax=ax, color=colors[1]) add_discrete_bands(bins, qts_50[0], qts_50[1], ax=ax, color=colors[2]) add_discrete_bands(bins, qts_30[0], qts_30[1], ax=ax, color=colors[3]) ax.step(bins[:-1], median, color=colors[4], lw=2, where=\"post\") ax.hist(y_obs, bins=bins, histtype=\"step\", lw=2, color=\"black\", align=\"mid\") handles = [ Line2D([], [], label=\"Observed data\", color=\"black\", lw=2), Line2D([], [], label=\"Posterior predictive median\", color=colors[4], lw=2) ] ax.legend(handles=handles) return ax zip_pps = zip_model.predict(idata=zip_idata, kind=\"pps\", inplace=False) bins = np.arange(39) fig, ax = plt.subplots(figsize=(7, 3)) ax = plot_ppc_discrete(zip_pps, bins, ax) ax.set_xlabel(\"Number of Fish Caught\") ax.set_ylabel(\"Count\") ax.set_title(\"ZIP model - Posterior Predictive Distribution\"); The model captures the number of zeros accurately. However, the model seems to slightly underestimate the counts 1 and 2. Nonetheless, the plot shows that the model captures the overall distribution of counts reasonably well.\nHurdle poisson Both ZIP and hurdle models both use two processes to generate data. The two models differ in their conceptualization of how the zeros are generated. In $\\text{ZIPoisson}$, the zeroes can come from any of the processes, while in the hurdle Poisson they come only from one of the processes. Thus, a hurdle model assumes zero and positive values are generated from two independent processes. In the hurdle model, there are two components: (1) a “structural” process such as a binary model for modeling whether the response variable is zero or not, and (2) a process using a truncated model such as a truncated Poisson for modeling the counts. The result of these two components is a distribution that can be described as\n$$P(Y=0) = 1 - \\psi$$\n$$P(Y=y_i) = \\psi \\frac{e^{-\\mu_i}\\mu_{i}^{y_i} / y_i!}{1 - e^{-\\mu_i}} \\ \\text{for} \\ y_i = 1, 2, 3,…,n$$\nwhere $y_i$ is the outcome, $\\mu$ is the mean of the Poisson process where $\\mu \\ge 0$, and $\\psi$ is the probability of the Poisson process where $0 \\lt \\psi \\lt 1$. The numerator of the second equation is the Poisson probability mass function, and the denominator is one minus the Poisson cumulative distribution function. This is a lot to digest. Again, let’s simulate some data to understand how data is generated from this process.\nx = np.arange(0, 22) psis = [0.7, 0.4] mus = [10, 4] plt.figure(figsize=(7, 3)) for psi, mu in zip(psis, mus): pmf = stats.poisson.pmf(x, mu) # pmf evaluated at x given mu cdf = stats.poisson.cdf(0, mu) # cdf evaluated at 0 given mu pmf[0] = 1 - psi # 1.) generate zeros pmf[1:] = (psi * pmf[1:]) / (1 - cdf) # 2.) generate counts pmf /= pmf.sum() # normalize to get probabilities plt.plot(x, pmf, '-o', label='$\\\\psi$ = {}, $\\\\mu$ = {}'.format(psi, mu)) plt.title(\"Hurdle Poisson Process\") plt.xlabel('x', fontsize=12) plt.ylabel('f(x)', fontsize=12) plt.legend(loc=1) plt.show() The differences between the ZIP and hurdle models are subtle. Notice how in the code for the hurdle Poisson process, the zero counts are generate by (1 - psi) versus (1 - psi) + pmf[0] for the ZIP process. Additionally, the positive observations are generated by the process (psi * pmf[1:]) / (1 - cdf) where the numerator is a vector of probabilities for positive counts scaled by $\\psi$ and the denominator uses the Poisson cumulative distribution function to evaluate the probability a count is greater than 0.\nHurdle regression model To add predictors in the hurdle model, we follow the same specification as in the ZIP regression model section since both models have the same structure. The only difference is that the hurdle model uses a truncated Poisson distribution instead of a ZIP distribution. Right away, we will model both the parent and non-parent parameter as a function of the predictors.\nhurdle_formula = bmb.Formula( \"count ~ livebait + camper + persons + child\", # parent parameter mu \"psi ~ livebait + camper + persons + child\" # non-parent parameter psi ) hurdle_model = bmb.Model( hurdle_formula, fish_data, family='hurdle_poisson' ) hurdle_idata = hurdle_model.fit( draws=1000, target_accept=0.95, random_seed=1234, chains=4 ) Auto-assigning NUTS sampler... Initializing NUTS using jitter+adapt_diag... Multiprocess sampling (4 chains in 4 jobs) NUTS: [Intercept, livebait, camper, persons, child, psi_Intercept, psi_livebait, psi_camper, psi_persons, psi_child] Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 6 seconds. hurdle_model Formula: count ~ livebait + camper + persons + child psi ~ livebait + camper + persons + child Family: hurdle_poisson Link: mu = log psi = logit Observations: 248 Priors: target = mu Common-level effects Intercept ~ Normal(mu: 0.0, sigma: 9.5283) livebait ~ Normal(mu: 0.0, sigma: 7.2685) camper ~ Normal(mu: 0.0, sigma: 5.0733) persons ~ Normal(mu: 0.0, sigma: 2.2583) child ~ Normal(mu: 0.0, sigma: 2.9419) target = psi Common-level effects psi_Intercept ~ Normal(mu: 0.0, sigma: 1.0) psi_livebait ~ Normal(mu: 0.0, sigma: 1.0) psi_camper ~ Normal(mu: 0.0, sigma: 1.0) psi_persons ~ Normal(mu: 0.0, sigma: 1.0) psi_child ~ Normal(mu: 0.0, sigma: 1.0) ------ * To see a plot of the priors call the .plot_priors() method. * To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace() hurdle_model.graph() As the same link functions are used for ZIP and Hurdle model, the coefficients can be interpreted in a similar manner.\naz.summary( hurdle_idata, var_names=[\"Intercept\", \"livebait\", \"camper\", \"persons\", \"child\"], filter_vars=\"like\" ) .dataframe tbody tr th { vertical-align: top; } .dataframe thead th { text-align: right; } Posterior predictive samples As with the ZIP model above, we plot the posterior predictive distribution against the observed data to see how well the model fits the data.\nhurdle_pps = hurdle_model.predict(idata=hurdle_idata, kind=\"pps\", inplace=False) bins = np.arange(39) fig, ax = plt.subplots(figsize=(7, 3)) ax = plot_ppc_discrete(hurdle_pps, bins, ax) ax.set_xlabel(\"Number of Fish Caught\") ax.set_ylabel(\"Count\") ax.set_title(\"Hurdle Model - Posterior Predictive Distribution\"); The plot looks similar to the ZIP model above. Nonetheless, the plot shows that the model captures the overall distribution of counts reasonably well.\nSummary In this notebook, two classes of models (ZIP and hurdle Poisson) for modeling zero-inflated data were presented and implemented in Bambi. The difference of the data generating process between the two models differ in how zeros are generated. The ZIP model uses a distribution that mixes two data generating processes. The first process generates zeros, and the second process uses a Poisson distribution to generate counts (of which some may be zero). The hurdle Poisson also uses two data generating processes, but doesn’t “mix” them. A process is used for generating zeros such as a binary model for modeling whether the response variable is zero or not, and a second process for modeling the counts. These two proceses are independent of each other.\nThe dataset used to demonstrate the two models had a large number of zeros. These zeros appeared because the group doesn’t fish, or because they fished, but caught zero fish. Because zeros could be generated due to two different reasons, the ZIP model, which allows zeros to be generated from a mixture of processes, seems to be more appropriate for this datset.\n%load_ext watermark %watermark -n -u -v -iv -w Last updated: Mon Sep 25 2023 Python implementation: CPython Python version : 3.11.0 IPython version : 8.13.2 seaborn : 0.12.2 numpy : 1.24.2 scipy : 1.11.2 bambi : 0.13.0.dev0 matplotlib: 3.7.1 arviz : 0.16.1 pandas : 2.1.0 Watermark: 2.3.1 ",
  "wordCount" : "3024",
  "inLanguage": "en",
  "datePublished": "2023-09-29T00:00:00Z",
  "dateModified": "2023-09-29T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Gabriel Stechschulte"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://gstechschulte.github.io/posts/bambi-zip-models/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Gabe's Gulch",
    "logo": {
      "@type": "ImageObject",
      "url": "https://gstechschulte.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://gstechschulte.github.io/" accesskey="h" title="Gabe&#39;s Gulch (Alt + H)">Gabe&#39;s Gulch</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://gstechschulte.github.io/categories/" title="categories">
                    <span>categories</span>
                </a>
            </li>
            <li>
                <a href="https://gstechschulte.github.io/tags/" title="tags">
                    <span>tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Zero Inflated Models in Bambi
    </h1>
    <div class="post-meta"><span title='2023-09-29 00:00:00 +0000 UTC'>September 29, 2023</span>&nbsp;·&nbsp;15 min&nbsp;·&nbsp;Gabriel Stechschulte

</div>
  </header> 
  <div class="post-content"><!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#| code-fold: true</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> arviz <span style="color:#66d9ef">as</span> az
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> matplotlib.pyplot <span style="color:#66d9ef">as</span> plt
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> matplotlib.lines <span style="color:#f92672">import</span> Line2D
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> pandas <span style="color:#66d9ef">as</span> pd
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> scipy.stats <span style="color:#66d9ef">as</span> stats
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> seaborn <span style="color:#66d9ef">as</span> sns
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> warnings
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> bambi <span style="color:#66d9ef">as</span> bmb
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>warnings<span style="color:#f92672">.</span>simplefilter(action<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;ignore&#39;</span>, category<span style="color:#f92672">=</span><span style="color:#a6e22e">FutureWarning</span>)
</span></span></code></pre></div><pre><code>WARNING (pytensor.tensor.blas): Using NumPy C-API based implementation for BLAS functions.
</code></pre>
<h1 id="zero-inflated-models">Zero inflated models<a hidden class="anchor" aria-hidden="true" href="#zero-inflated-models">#</a></h1>
<p>This blog post is a copy of the zero inflated models documentation I wrote for <a href="https://bambinos.github.io/bambi/">Bambi</a>. The original post can be found <a href="https://bambinos.github.io/bambi/notebooks/">here</a>.</p>
<p>In this notebook, we will describe zero inflated outcomes and why the data generating process behind these outcomes requires a special class of generalized linear models: zero-inflated Poisson (ZIP) and hurdle Poisson. Subsequently, we will describe and implement each model using a set of zero-inflated data from ecology. Along the way, we will also use the <code>interpret</code> sub-package to interpret the predictions and parameters of the models.</p>
<h2 id="zero-inflated-outcomes">Zero inflated outcomes<a hidden class="anchor" aria-hidden="true" href="#zero-inflated-outcomes">#</a></h2>
<p>Sometimes, an observation is not generated from a single process, but from a <em>mixture</em> of processes. Whenever there is a mixture of processes generating an observation, a mixture model may be more appropriate. A mixture model uses more than one probability distribution to model the data. Count data are more susceptible to needing a mixture model as it is common to have a large number of zeros <strong>and</strong> values greater than zero.  A zero means &ldquo;nothing happened&rdquo;, and this can be either because the rate of events is low, or because the process that generates the events was never &ldquo;triggered&rdquo;. For example, in health service utilization data (the number of times a patient used a service during a given time period), a large number of zeros represents patients with no utilization during the time period. However, some patients do use a service which is a result of some &ldquo;triggered process&rdquo;.</p>
<p>There are two popular classes of models for modeling zero-inflated data: (1) ZIP, and (2) hurdle Poisson. First, the ZIP model is described and how to implement it in Bambi is outlined. Subsequently, the hurdle Poisson model and how to implement it is outlined thereafter.</p>
<h2 id="zero-inflated-poisson">Zero inflated poisson<a hidden class="anchor" aria-hidden="true" href="#zero-inflated-poisson">#</a></h2>
<p>To model zero-inflated outcomes, the ZIP model uses a distribution that mixes two data generating processes. The first process generates zeros, and the second process uses a Poisson distribution to generate counts (of which some may be zero). The result of this mixture is a distribution that can be described as</p>
<p>$$P(Y=0) = (1 - \psi) + \psi e^{-\mu}$$</p>
<p>$$P(Y=y_i) = \psi \frac{e^{-\mu} \mu_{i}^y}{y_{i}!} \ \text{for} \ y_i = 1, 2, 3,&hellip;,n$$</p>
<p>where $y_i$ is the outcome, $\mu$ is the mean of the Poisson process where $\mu \ge 0$, and $\psi$ is the probability of the Poisson process where $0 \lt \psi \lt 1$. To understand how these two processes are &ldquo;mixed&rdquo;, let&rsquo;s simulate some data using the two process equations above (taken from the PyMC <a href="https://www.pymc.io/projects/docs/en/latest/api/distributions/generated/pymc.ZeroInflatedPoisson.html">docs</a>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">22</span>)
</span></span><span style="display:flex;"><span>psis <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0.7</span>, <span style="color:#ae81ff">0.4</span>]
</span></span><span style="display:flex;"><span>mus <span style="color:#f92672">=</span> [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> psi, mu <span style="color:#f92672">in</span> zip(psis, mus):
</span></span><span style="display:flex;"><span>    pmf <span style="color:#f92672">=</span> stats<span style="color:#f92672">.</span>poisson<span style="color:#f92672">.</span>pmf(x, mu)
</span></span><span style="display:flex;"><span>    pmf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> psi) <span style="color:#f92672">+</span> pmf[<span style="color:#ae81ff">0</span>] <span style="color:#75715e"># 1.) generate zeros</span>
</span></span><span style="display:flex;"><span>    pmf[<span style="color:#ae81ff">1</span>:] <span style="color:#f92672">=</span>  psi <span style="color:#f92672">*</span> pmf[<span style="color:#ae81ff">1</span>:] <span style="color:#75715e"># 2.) generate counts</span>
</span></span><span style="display:flex;"><span>    pmf <span style="color:#f92672">/=</span> pmf<span style="color:#f92672">.</span>sum() <span style="color:#75715e"># normalize to get probabilities</span>
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot(x, pmf, <span style="color:#e6db74">&#39;-o&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;$</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">psi$ = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, $</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">mu$ = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(psi, mu))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Zero Inflated Poisson Process&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;x&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;f(x)&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_5_0.png" alt="png"  />
</p>
<p>Notice how the blue line, corresponding to a higher $\psi$ and $\mu$, has a higher rate of counts and less zeros. Additionally, the inline comments above describe the first and second process generating the data.</p>
<h3 id="zip-regression-model">ZIP regression model<a hidden class="anchor" aria-hidden="true" href="#zip-regression-model">#</a></h3>
<p>The equations above only describe the ZIP distribution. However, predictors can be added to make this a regression model. Suppose we have a response variable $Y$, which represents the number of events that occur during a time period, and $p$ predictors $X_1, X_2, &hellip;, X_p$. We can model the parameters of the ZIP distribution as a linear combination of the predictors.</p>
<p>$$Y_i \sim \text{ZIPoisson}(\mu_i, \psi_i)$$</p>
<p>$$g(\mu_i) = \beta_0 + \beta_1 X_{1i}+,&hellip;,+\beta_p X_{pi}$$</p>
<p>$$h(\psi_i) = \alpha_0 + \alpha_1 X_{1i}+,&hellip;,+\alpha_p X_{pi}$$</p>
<p>where $g$ and $h$ are the link functions for each parameter. Bambi, by default, uses the log link for $g$ and the logit link for $h$. Notice how there are two linear models and two link functions: one for each parameter in the $\text{ZIPoisson}$. The parameters of the linear model differ, because any predictor such as $X$ may be associated differently with each part of the mixture. Actually, you don&rsquo;t even need to use the same predictors in both linear models—but this beyond the scope of this notebook.</p>
<h4 id="the-fish-dataset">The fish dataset<a hidden class="anchor" aria-hidden="true" href="#the-fish-dataset">#</a></h4>
<p>To demonstrate the ZIP regression model, we model and predict how many fish are caught by visitors at a state park using survey <a href="%22https://stats.idre.ucla.edu/stat/data/fish.csv%22">data</a>. Many visitors catch zero fish, either because they did not fish at all, or because they were unlucky. The dataset contains data on 250 groups that went to a state park to fish. Each group was questioned about how many fish they caught (<code>count</code>), how many children were in the group (<code>child</code>), how many people were in the group (<code>persons</code>), if they used a live bait (<code>livebait</code>) and whether or not they brought a camper to the park (<code>camper</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fish_data <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>read_stata(<span style="color:#e6db74">&#34;http://www.stata-press.com/data/r11/fish.dta&#34;</span>)
</span></span><span style="display:flex;"><span>cols <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;count&#34;</span>, <span style="color:#e6db74">&#34;livebait&#34;</span>, <span style="color:#e6db74">&#34;camper&#34;</span>, <span style="color:#e6db74">&#34;persons&#34;</span>, <span style="color:#e6db74">&#34;child&#34;</span>]
</span></span><span style="display:flex;"><span>fish_data <span style="color:#f92672">=</span> fish_data[cols]
</span></span><span style="display:flex;"><span>fish_data[<span style="color:#e6db74">&#34;livebait&#34;</span>] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>Categorical(fish_data[<span style="color:#e6db74">&#34;livebait&#34;</span>])
</span></span><span style="display:flex;"><span>fish_data[<span style="color:#e6db74">&#34;camper&#34;</span>] <span style="color:#f92672">=</span> pd<span style="color:#f92672">.</span>Categorical(fish_data[<span style="color:#e6db74">&#34;camper&#34;</span>])
</span></span><span style="display:flex;"><span>fish_data <span style="color:#f92672">=</span> fish_data[fish_data[<span style="color:#e6db74">&#34;count&#34;</span>] <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">60</span>] <span style="color:#75715e"># remove outliers</span>
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fish_data<span style="color:#f92672">.</span>head()
</span></span></code></pre></div><!-- raw HTML omitted -->
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e"># Excess zeros, and skewed count</span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>sns<span style="color:#f92672">.</span>histplot(fish_data[<span style="color:#e6db74">&#34;count&#34;</span>], discrete<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#34;Number of Fish Caught&#34;</span>);
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_11_0.png" alt="png"  />
</p>
<p>To fit a ZIP regression model, we pass <code>family=zero_inflated_poisson</code> to the <code>bmb.Model</code> constructor.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>zip_model <span style="color:#f92672">=</span> bmb<span style="color:#f92672">.</span>Model(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;count ~ livebait + camper + persons + child&#34;</span>,
</span></span><span style="display:flex;"><span>    fish_data,
</span></span><span style="display:flex;"><span>    family<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zero_inflated_poisson&#39;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>zip_idata <span style="color:#f92672">=</span> zip_model<span style="color:#f92672">.</span>fit(
</span></span><span style="display:flex;"><span>    draws<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    target_accept<span style="color:#f92672">=</span><span style="color:#ae81ff">0.95</span>,
</span></span><span style="display:flex;"><span>    random_seed<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span>,
</span></span><span style="display:flex;"><span>    chains<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [count_psi, Intercept, livebait, camper, persons, child]
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 4 seconds.
</code></pre>
<p>Lets take a look at the model components. Why is there only one linear model and link function defined for $\mu$. Where is the linear model and link function for $\psi$? By default, the &ldquo;main&rdquo; (or first) formula is defined for the parent parameter; in this case $\mu$. Since we didn&rsquo;t pass an additional formula for the non-parent parameter $\psi$, $\psi$ was never modeled as a function of the predictors as explained above. If we want to model both $\mu$ and $\psi$ as a function of the predictor, we need to expicitly pass two formulas.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>zip_model
</span></span></code></pre></div><pre><code>       Formula: count ~ livebait + camper + persons + child
        Family: zero_inflated_poisson
          Link: mu = log
  Observations: 248
        Priors:
    target = mu
        Common-level effects
            Intercept ~ Normal(mu: 0.0, sigma: 9.5283)
            livebait ~ Normal(mu: 0.0, sigma: 7.2685)
            camper ~ Normal(mu: 0.0, sigma: 5.0733)
            persons ~ Normal(mu: 0.0, sigma: 2.2583)
            child ~ Normal(mu: 0.0, sigma: 2.9419)

        Auxiliary parameters
            psi ~ Beta(alpha: 2.0, beta: 2.0)
------
* To see a plot of the priors call the .plot_priors() method.
* To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace()
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>formula <span style="color:#f92672">=</span> bmb<span style="color:#f92672">.</span>Formula(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;count ~ livebait + camper + persons + child&#34;</span>, <span style="color:#75715e"># parent parameter mu</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;psi ~ livebait + camper + persons + child&#34;</span>    <span style="color:#75715e"># non-parent parameter psi</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>zip_model <span style="color:#f92672">=</span> bmb<span style="color:#f92672">.</span>Model(
</span></span><span style="display:flex;"><span>    formula,
</span></span><span style="display:flex;"><span>    fish_data,
</span></span><span style="display:flex;"><span>    family<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;zero_inflated_poisson&#39;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>zip_idata <span style="color:#f92672">=</span> zip_model<span style="color:#f92672">.</span>fit(
</span></span><span style="display:flex;"><span>    draws<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    target_accept<span style="color:#f92672">=</span><span style="color:#ae81ff">0.95</span>,
</span></span><span style="display:flex;"><span>    random_seed<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span>,
</span></span><span style="display:flex;"><span>    chains<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [Intercept, livebait, camper, persons, child, psi_Intercept, psi_livebait, psi_camper, psi_persons, psi_child]
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 6 seconds.
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>zip_model
</span></span></code></pre></div><pre><code>       Formula: count ~ livebait + camper + persons + child
                psi ~ livebait + camper + persons + child
        Family: zero_inflated_poisson
          Link: mu = log
                psi = logit
  Observations: 248
        Priors:
    target = mu
        Common-level effects
            Intercept ~ Normal(mu: 0.0, sigma: 9.5283)
            livebait ~ Normal(mu: 0.0, sigma: 7.2685)
            camper ~ Normal(mu: 0.0, sigma: 5.0733)
            persons ~ Normal(mu: 0.0, sigma: 2.2583)
            child ~ Normal(mu: 0.0, sigma: 2.9419)
    target = psi
        Common-level effects
            psi_Intercept ~ Normal(mu: 0.0, sigma: 1.0)
            psi_livebait ~ Normal(mu: 0.0, sigma: 1.0)
            psi_camper ~ Normal(mu: 0.0, sigma: 1.0)
            psi_persons ~ Normal(mu: 0.0, sigma: 1.0)
            psi_child ~ Normal(mu: 0.0, sigma: 1.0)
------
* To see a plot of the priors call the .plot_priors() method.
* To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace()
</code></pre>
<p>Now, both $\mu$ and $\psi$ are defined as a function of a linear combination of the predictors. Additionally, we can see that the log and logit link functions are defined for $\mu$ and $\psi$, respectively.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>zip_model<span style="color:#f92672">.</span>graph()
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_19_0.svg" alt="svg"  />
</p>
<p>Since each parameter has a different link function, and each parameter has a different meaning, we must be careful on how the coefficients are interpreted. Coefficients without the substring &ldquo;psi&rdquo; correspond to the $\mu$ parameter (the mean of the Poisson process) and are on the log scale. Coefficients with the substring &ldquo;psi&rdquo; correspond to the $\psi$ parameter (this can be thought of as the log-odds of non-zero data) and are on the logit scale. Interpreting these coefficients can be easier with the <code>interpret</code> sub-package. Below, we will show how to use this sub-package to interpret the coefficients conditional on a set of the predictors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>az<span style="color:#f92672">.</span>summary(
</span></span><span style="display:flex;"><span>    zip_idata,
</span></span><span style="display:flex;"><span>    var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Intercept&#34;</span>, <span style="color:#e6db74">&#34;livebait&#34;</span>, <span style="color:#e6db74">&#34;camper&#34;</span>, <span style="color:#e6db74">&#34;persons&#34;</span>, <span style="color:#e6db74">&#34;child&#34;</span>],
</span></span><span style="display:flex;"><span>    filter_vars<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;like&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><!-- raw HTML omitted -->
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<h4 id="interpret-model-parameters">Interpret model parameters<a hidden class="anchor" aria-hidden="true" href="#interpret-model-parameters">#</a></h4>
<p>Since we have fit a distributional model, we can leverage the <code>plot_predictions()</code> function in the <code>interpret</code> sub-package to visualize how the $\text{ZIPoisson}$ parameters $\mu$ and $\psi$ vary as a covariate changes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(nrows<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>, ncols<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bmb<span style="color:#f92672">.</span>interpret<span style="color:#f92672">.</span>plot_predictions(
</span></span><span style="display:flex;"><span>    zip_model,
</span></span><span style="display:flex;"><span>    zip_idata,
</span></span><span style="display:flex;"><span>    covariates<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;persons&#34;</span>,
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;mu (fish count)&#34;</span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;$</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">mu$ as a function of persons&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bmb<span style="color:#f92672">.</span>interpret<span style="color:#f92672">.</span>plot_predictions(
</span></span><span style="display:flex;"><span>    zip_model,
</span></span><span style="display:flex;"><span>    zip_idata,
</span></span><span style="display:flex;"><span>    covariates<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;persons&#34;</span>,
</span></span><span style="display:flex;"><span>    target<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;psi&#34;</span>,
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">=</span>ax[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>ax[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;$</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">psi$ as a function of persons&#34;</span>);
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_23_0.png" alt="png"  />
</p>
<p>Interpreting the left plot (the $\mu$ parameter) as the number of people in a group fishing increases, so does the number of fish caught. The right plot (the $\psi$ parameter) shows that as the number of people in a group fishing increases, the probability of the Poisson process increases. One interpretation of this is that as the number of people in a group increases, the probability of catching no fish decreases.</p>
<h4 id="posterior-predictive-distribution">Posterior predictive distribution<a hidden class="anchor" aria-hidden="true" href="#posterior-predictive-distribution">#</a></h4>
<p>Lastly, lets plot the posterior predictive distribution against the observed data to see how well the model fits the data. To plot the samples, a utility function is defined below to assist in the plotting of discrete values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">adjust_lightness</span>(color, amount<span style="color:#f92672">=</span><span style="color:#ae81ff">0.5</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> matplotlib.colors <span style="color:#66d9ef">as</span> mc
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">import</span> colorsys
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">try</span>:
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> mc<span style="color:#f92672">.</span>cnames[color]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">except</span>:
</span></span><span style="display:flex;"><span>        c <span style="color:#f92672">=</span> color
</span></span><span style="display:flex;"><span>    c <span style="color:#f92672">=</span> colorsys<span style="color:#f92672">.</span>rgb_to_hls(<span style="color:#f92672">*</span>mc<span style="color:#f92672">.</span>to_rgb(c))
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> colorsys<span style="color:#f92672">.</span>hls_to_rgb(c[<span style="color:#ae81ff">0</span>], c[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> amount, c[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">plot_ppc_discrete</span>(idata, bins, ax):
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">add_discrete_bands</span>(x, lower, upper, ax, <span style="color:#f92672">**</span>kwargs):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i, (l, u) <span style="color:#f92672">in</span> enumerate(zip(lower, upper)):
</span></span><span style="display:flex;"><span>            s <span style="color:#f92672">=</span> slice(i, i <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>            ax<span style="color:#f92672">.</span>fill_between(x[s], [l, l], [u, u], <span style="color:#f92672">**</span>kwargs)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    var_name <span style="color:#f92672">=</span> list(idata<span style="color:#f92672">.</span>observed_data<span style="color:#f92672">.</span>data_vars)[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    y_obs <span style="color:#f92672">=</span> idata<span style="color:#f92672">.</span>observed_data[var_name]<span style="color:#f92672">.</span>to_numpy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    counts_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> draw_values <span style="color:#f92672">in</span> az<span style="color:#f92672">.</span>extract(idata, <span style="color:#e6db74">&#34;posterior_predictive&#34;</span>)[var_name]<span style="color:#f92672">.</span>to_numpy()<span style="color:#f92672">.</span>T:
</span></span><span style="display:flex;"><span>        counts, _ <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>histogram(draw_values, bins<span style="color:#f92672">=</span>bins)
</span></span><span style="display:flex;"><span>        counts_list<span style="color:#f92672">.</span>append(counts)
</span></span><span style="display:flex;"><span>    counts_arr <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>stack(counts_list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    qts_90 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(counts_arr, (<span style="color:#ae81ff">0.05</span>, <span style="color:#ae81ff">0.95</span>), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    qts_70 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(counts_arr, (<span style="color:#ae81ff">0.15</span>, <span style="color:#ae81ff">0.85</span>), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    qts_50 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(counts_arr, (<span style="color:#ae81ff">0.25</span>, <span style="color:#ae81ff">0.75</span>), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    qts_30 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(counts_arr, (<span style="color:#ae81ff">0.35</span>, <span style="color:#ae81ff">0.65</span>), axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    median <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>quantile(counts_arr, <span style="color:#ae81ff">0.5</span>, axis<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    colors <span style="color:#f92672">=</span> [adjust_lightness(<span style="color:#e6db74">&#34;C0&#34;</span>, x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> [<span style="color:#ae81ff">1.8</span>, <span style="color:#ae81ff">1.6</span>, <span style="color:#ae81ff">1.4</span>, <span style="color:#ae81ff">1.2</span>, <span style="color:#ae81ff">0.9</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    add_discrete_bands(bins, qts_90[<span style="color:#ae81ff">0</span>], qts_90[<span style="color:#ae81ff">1</span>], ax<span style="color:#f92672">=</span>ax, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>    add_discrete_bands(bins, qts_70[<span style="color:#ae81ff">0</span>], qts_70[<span style="color:#ae81ff">1</span>], ax<span style="color:#f92672">=</span>ax, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    add_discrete_bands(bins, qts_50[<span style="color:#ae81ff">0</span>], qts_50[<span style="color:#ae81ff">1</span>], ax<span style="color:#f92672">=</span>ax, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>    add_discrete_bands(bins, qts_30[<span style="color:#ae81ff">0</span>], qts_30[<span style="color:#ae81ff">1</span>], ax<span style="color:#f92672">=</span>ax, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">3</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">.</span>step(bins[:<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>], median, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">4</span>], lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, where<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;post&#34;</span>)
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">.</span>hist(y_obs, bins<span style="color:#f92672">=</span>bins, histtype<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;step&#34;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, align<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;mid&#34;</span>)
</span></span><span style="display:flex;"><span>    handles <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>        Line2D([], [], label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Observed data&#34;</span>, color<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;black&#34;</span>, lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>),
</span></span><span style="display:flex;"><span>        Line2D([], [], label<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;Posterior predictive median&#34;</span>, color<span style="color:#f92672">=</span>colors[<span style="color:#ae81ff">4</span>], lw<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>    ax<span style="color:#f92672">.</span>legend(handles<span style="color:#f92672">=</span>handles)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> ax
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>zip_pps <span style="color:#f92672">=</span> zip_model<span style="color:#f92672">.</span>predict(idata<span style="color:#f92672">=</span>zip_idata, kind<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;pps&#34;</span>, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bins <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">39</span>)
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>ax <span style="color:#f92672">=</span> plot_ppc_discrete(zip_pps, bins, ax)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;Number of Fish Caught&#34;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;Count&#34;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;ZIP model - Posterior Predictive Distribution&#34;</span>);
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_27_0.png" alt="png"  />
</p>
<p>The model captures the number of zeros accurately. However, the model seems to slightly underestimate the counts 1 and 2. Nonetheless, the plot shows that the model captures the overall distribution of counts reasonably well.</p>
<h2 id="hurdle-poisson">Hurdle poisson<a hidden class="anchor" aria-hidden="true" href="#hurdle-poisson">#</a></h2>
<p>Both ZIP and hurdle models both use two processes to generate data. The two models differ in their conceptualization of how the zeros are generated. In $\text{ZIPoisson}$, the zeroes can come from any of the processes, while in the hurdle Poisson they come only from one of the processes. Thus, a hurdle model assumes zero and positive values are generated from two independent processes. In the hurdle model, there are two components: (1) a &ldquo;structural&rdquo; process such as a binary model for modeling whether the response variable is zero or not, and (2) a process using a truncated model such as a truncated Poisson for modeling the counts. The result of these two components is a distribution that can be described as</p>
<p>$$P(Y=0) = 1 - \psi$$</p>
<p>$$P(Y=y_i) = \psi \frac{e^{-\mu_i}\mu_{i}^{y_i} / y_i!}{1 - e^{-\mu_i}} \ \text{for} \ y_i = 1, 2, 3,&hellip;,n$$</p>
<p>where $y_i$ is the outcome, $\mu$ is the mean of the Poisson process where $\mu \ge 0$, and $\psi$ is the probability of the Poisson process where $0 \lt \psi \lt 1$. The numerator of the second equation is the Poisson probability mass function, and the denominator is one minus the Poisson cumulative distribution function. This is a lot to digest. Again, let&rsquo;s simulate some data to understand how data is generated from this process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">22</span>)
</span></span><span style="display:flex;"><span>psis <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0.7</span>, <span style="color:#ae81ff">0.4</span>]
</span></span><span style="display:flex;"><span>mus <span style="color:#f92672">=</span> [<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>figure(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> psi, mu <span style="color:#f92672">in</span> zip(psis, mus):
</span></span><span style="display:flex;"><span>    pmf <span style="color:#f92672">=</span> stats<span style="color:#f92672">.</span>poisson<span style="color:#f92672">.</span>pmf(x, mu) <span style="color:#75715e"># pmf evaluated at x given mu</span>
</span></span><span style="display:flex;"><span>    cdf <span style="color:#f92672">=</span> stats<span style="color:#f92672">.</span>poisson<span style="color:#f92672">.</span>cdf(<span style="color:#ae81ff">0</span>, mu) <span style="color:#75715e"># cdf evaluated at 0 given mu</span>
</span></span><span style="display:flex;"><span>    pmf[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> psi <span style="color:#75715e"># 1.) generate zeros</span>
</span></span><span style="display:flex;"><span>    pmf[<span style="color:#ae81ff">1</span>:] <span style="color:#f92672">=</span>  (psi <span style="color:#f92672">*</span> pmf[<span style="color:#ae81ff">1</span>:]) <span style="color:#f92672">/</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> cdf) <span style="color:#75715e"># 2.) generate counts</span>
</span></span><span style="display:flex;"><span>    pmf <span style="color:#f92672">/=</span> pmf<span style="color:#f92672">.</span>sum() <span style="color:#75715e"># normalize to get probabilities</span>
</span></span><span style="display:flex;"><span>    plt<span style="color:#f92672">.</span>plot(x, pmf, <span style="color:#e6db74">&#39;-o&#39;</span>, label<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;$</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">psi$ = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">, $</span><span style="color:#ae81ff">\\</span><span style="color:#e6db74">mu$ = </span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#39;</span><span style="color:#f92672">.</span>format(psi, mu))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>title(<span style="color:#e6db74">&#34;Hurdle Poisson Process&#34;</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>xlabel(<span style="color:#e6db74">&#39;x&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>ylabel(<span style="color:#e6db74">&#39;f(x)&#39;</span>, fontsize<span style="color:#f92672">=</span><span style="color:#ae81ff">12</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>legend(loc<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>plt<span style="color:#f92672">.</span>show()
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_30_0.png" alt="png"  />
</p>
<p>The differences between the ZIP and hurdle models are subtle. Notice how in the code for the hurdle Poisson process, the zero counts are generate by <code>(1 - psi)</code> versus <code>(1 - psi) + pmf[0]</code> for the ZIP process. Additionally, the positive observations are generated by the process <code>(psi * pmf[1:]) / (1 - cdf)</code> where the numerator is a vector of probabilities for positive counts scaled by $\psi$ and the denominator uses the Poisson cumulative distribution function to evaluate the probability a count is greater than 0.</p>
<h3 id="hurdle-regression-model">Hurdle regression model<a hidden class="anchor" aria-hidden="true" href="#hurdle-regression-model">#</a></h3>
<p>To add predictors in the hurdle model, we follow the same specification as in the <em>ZIP regression model</em> section since both models have the same structure. The only difference is that the hurdle model uses a truncated Poisson distribution instead of a ZIP distribution. Right away, we will model both the parent and non-parent parameter as a function of the predictors.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hurdle_formula <span style="color:#f92672">=</span> bmb<span style="color:#f92672">.</span>Formula(
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;count ~ livebait + camper + persons + child&#34;</span>, <span style="color:#75715e"># parent parameter mu</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;psi ~ livebait + camper + persons + child&#34;</span>    <span style="color:#75715e"># non-parent parameter psi</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hurdle_model <span style="color:#f92672">=</span> bmb<span style="color:#f92672">.</span>Model(
</span></span><span style="display:flex;"><span>    hurdle_formula,
</span></span><span style="display:flex;"><span>    fish_data,
</span></span><span style="display:flex;"><span>    family<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;hurdle_poisson&#39;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>hurdle_idata <span style="color:#f92672">=</span> hurdle_model<span style="color:#f92672">.</span>fit(
</span></span><span style="display:flex;"><span>    draws<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>,
</span></span><span style="display:flex;"><span>    target_accept<span style="color:#f92672">=</span><span style="color:#ae81ff">0.95</span>,
</span></span><span style="display:flex;"><span>    random_seed<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span>,
</span></span><span style="display:flex;"><span>    chains<span style="color:#f92672">=</span><span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><pre><code>Auto-assigning NUTS sampler...
Initializing NUTS using jitter+adapt_diag...
Multiprocess sampling (4 chains in 4 jobs)
NUTS: [Intercept, livebait, camper, persons, child, psi_Intercept, psi_livebait, psi_camper, psi_persons, psi_child]
</code></pre>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<pre><code>Sampling 4 chains for 1_000 tune and 1_000 draw iterations (4_000 + 4_000 draws total) took 6 seconds.
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hurdle_model
</span></span></code></pre></div><pre><code>       Formula: count ~ livebait + camper + persons + child
                psi ~ livebait + camper + persons + child
        Family: hurdle_poisson
          Link: mu = log
                psi = logit
  Observations: 248
        Priors:
    target = mu
        Common-level effects
            Intercept ~ Normal(mu: 0.0, sigma: 9.5283)
            livebait ~ Normal(mu: 0.0, sigma: 7.2685)
            camper ~ Normal(mu: 0.0, sigma: 5.0733)
            persons ~ Normal(mu: 0.0, sigma: 2.2583)
            child ~ Normal(mu: 0.0, sigma: 2.9419)
    target = psi
        Common-level effects
            psi_Intercept ~ Normal(mu: 0.0, sigma: 1.0)
            psi_livebait ~ Normal(mu: 0.0, sigma: 1.0)
            psi_camper ~ Normal(mu: 0.0, sigma: 1.0)
            psi_persons ~ Normal(mu: 0.0, sigma: 1.0)
            psi_child ~ Normal(mu: 0.0, sigma: 1.0)
------
* To see a plot of the priors call the .plot_priors() method.
* To see a summary or plot of the posterior pass the object returned by .fit() to az.summary() or az.plot_trace()
</code></pre>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hurdle_model<span style="color:#f92672">.</span>graph()
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_35_0.svg" alt="svg"  />
</p>
<p>As the same link functions are used for ZIP and Hurdle model, the coefficients can be interpreted in a similar manner.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>az<span style="color:#f92672">.</span>summary(
</span></span><span style="display:flex;"><span>    hurdle_idata,
</span></span><span style="display:flex;"><span>    var_names<span style="color:#f92672">=</span>[<span style="color:#e6db74">&#34;Intercept&#34;</span>, <span style="color:#e6db74">&#34;livebait&#34;</span>, <span style="color:#e6db74">&#34;camper&#34;</span>, <span style="color:#e6db74">&#34;persons&#34;</span>, <span style="color:#e6db74">&#34;child&#34;</span>],
</span></span><span style="display:flex;"><span>    filter_vars<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;like&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span></code></pre></div><!-- raw HTML omitted -->
<pre><code>.dataframe tbody tr th {
    vertical-align: top;
}

.dataframe thead th {
    text-align: right;
}
</code></pre>
<p><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<h4 id="posterior-predictive-samples">Posterior predictive samples<a hidden class="anchor" aria-hidden="true" href="#posterior-predictive-samples">#</a></h4>
<p>As with the ZIP model above, we plot the posterior predictive distribution against the observed data to see how well the model fits the data.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>hurdle_pps <span style="color:#f92672">=</span> hurdle_model<span style="color:#f92672">.</span>predict(idata<span style="color:#f92672">=</span>hurdle_idata, kind<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;pps&#34;</span>, inplace<span style="color:#f92672">=</span><span style="color:#66d9ef">False</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bins <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>arange(<span style="color:#ae81ff">39</span>)
</span></span><span style="display:flex;"><span>fig, ax <span style="color:#f92672">=</span> plt<span style="color:#f92672">.</span>subplots(figsize<span style="color:#f92672">=</span>(<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">3</span>))
</span></span><span style="display:flex;"><span>ax <span style="color:#f92672">=</span> plot_ppc_discrete(hurdle_pps, bins, ax)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_xlabel(<span style="color:#e6db74">&#34;Number of Fish Caught&#34;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_ylabel(<span style="color:#e6db74">&#34;Count&#34;</span>)
</span></span><span style="display:flex;"><span>ax<span style="color:#f92672">.</span>set_title(<span style="color:#e6db74">&#34;Hurdle Model - Posterior Predictive Distribution&#34;</span>);
</span></span></code></pre></div><p><img loading="lazy" src="2023-09-29-zip-models-bambi_files/2023-09-29-zip-models-bambi_39_0.png" alt="png"  />
</p>
<p>The plot looks similar to the ZIP model above. Nonetheless, the plot shows that the model captures the overall distribution of counts reasonably well.</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>In this notebook, two classes of models (ZIP and hurdle Poisson) for modeling zero-inflated data were presented and implemented in Bambi. The difference of the data generating process between the two models differ in how zeros are generated. The ZIP model uses a distribution that mixes two data generating processes. The first process generates zeros, and the second process uses a Poisson distribution to generate counts (of which some may be zero). The hurdle Poisson also uses two data generating processes, but doesn&rsquo;t &ldquo;mix&rdquo; them. A process is used for generating zeros such as a binary model for modeling whether the response variable is zero or not, and a second process for modeling the counts. These two proceses are independent of each other.</p>
<p>The dataset used to demonstrate the two models had a large number of zeros. These zeros appeared because the group doesn&rsquo;t fish, or because they fished, but caught zero fish. Because zeros could be generated due to two different reasons, the ZIP model, which allows zeros to be generated from a mixture of processes, seems to be more appropriate for this datset.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">%</span>load_ext watermark
</span></span><span style="display:flex;"><span><span style="color:#f92672">%</span>watermark <span style="color:#f92672">-</span>n <span style="color:#f92672">-</span>u <span style="color:#f92672">-</span>v <span style="color:#f92672">-</span>iv <span style="color:#f92672">-</span>w
</span></span></code></pre></div><pre><code>Last updated: Mon Sep 25 2023

Python implementation: CPython
Python version       : 3.11.0
IPython version      : 8.13.2

seaborn   : 0.12.2
numpy     : 1.24.2
scipy     : 1.11.2
bambi     : 0.13.0.dev0
matplotlib: 3.7.1
arviz     : 0.16.1
pandas    : 2.1.0

Watermark: 2.3.1
</code></pre>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://gstechschulte.github.io/">Gabe&#39;s Gulch</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
